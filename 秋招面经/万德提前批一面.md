
1. 学生类可以作为hashmap的key吗？为什么？
    - 可以，因为学生类重写了`hashCode()`和`equals()`方法，确保了对象的唯一性。
    - 要求把学生类的值类型设为不可变类型，确保在作为key时不会改变，加final。
2. 性别字段需要加索引吗？为什么？
    - 不需要，因为性别字段的值域较小（只有男和女），且查询时不会频繁使用该字段进行过滤或排序。
3. 如何让一个类不可以被继承？
    - 可以使用`final`关键字修饰类，防止其他类继承该类。
4. ES中是如何实现相关度排序的？
    - ES使用BM25算法来计算文档与查询的相关度。BM25考虑了词频、文档长度和逆文档频率等因素，综合评估文档与查询的匹配程度。
5. mysql中什么时候索引会失效？
    - 当使用了`LIKE`模糊查询（前缀不为通配符）、函数操作、类型转换、或者索引列的值为NULL时，索引可能会失效。
    - 另外，当查询条件中包含了大量的行（例如全表扫描）时，索引也可能失效。
6. 分布式事务的解决方案有哪些？
    - 分布式事务可以通过以下几种方式解决：
        - **两阶段提交（2PC）**：协调者先询问各参与者是否准备好提交，所有参与者同意后再提交。
        - **三阶段提交（3PC）**：在两阶段提交的基础上增加了一个准备阶段，减少了阻塞时间。
        - **TCC（Try-Confirm-Cancel）**：将事务分为尝试、确认和取消三个阶段，适用于需要精确控制的场景。
        - **Saga模式**：将长事务拆分为一系列短事务，每个短事务都有对应的补偿操作。
        - **消息队列**：通过异步消息传递来实现最终一致性，适用于高并发场景。
7. 讲一下G1垃圾回收器的工作原理。
    - G1垃圾回收器将堆内存划分为多个小块（Region），每个Region可以是年轻代或老年代。G1通过并行和增量的方式进行垃圾回收，首先标记活跃对象，然后清理无用对象，最后整理内存以减少碎片。G1还支持预测停顿时间，能够在一定程度上控制垃圾回收的停顿时间。
    - G1的优点是能够处理大内存应用，且在多核处理器上表现良好。它通过分代收集和并行处理来提高性能，并且可以在后台进行垃圾回收，减少应用停顿时间。
8. 线程池的核心线程数的设置原则是什么？
    - 核心线程数的设置应根据系统的硬件资源（如CPU核心数）、任务的性质（CPU密集型或IO密集型）以及预期的并发量来决定。一般来说：
        - 对于CPU密集型任务，核心线程数可以设置为CPU核心数的1-2倍。
        - 对于IO密集型任务，核心线程数可以设置为CPU核心数的2-4倍。
    - 还需要考虑系统的负载和响应时间要求，确保线程池能够高效处理任务而不会造成过多的上下文切换或资源竞争。
9. 如何解决循环依赖问题？
    - 循环依赖可以通过以下几种方式解决：
        - **使用接口**：将循环依赖的类抽象为接口，通过接口注入来打破循环。
        - **延迟加载**：使用懒加载或代理模式，延迟初始化依赖对象，避免在构造函数中直接引用。
        - **重构代码**：重新设计类的职责，将循环依赖的部分拆分到其他类中，减少耦合。
        - **使用容器管理**：在Spring等依赖注入框架中，可以通过`@Lazy`注解或`@PostConstruct`方法来解决循环依赖问题。
